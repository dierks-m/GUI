-- Variables --
local rawArgs = {...}

local object = rawArgs[2]
local args = rawArgs[1]
object.GUIObjectType = 0x02

bAssert(type(args.text) == "nil" or type(args.text) == "table", "Text must be given in table form", 1)
bAssert(type(args.variables) == "nil" or type(args.variables) == "table", "Variables must be given in table form", 1)

if args.text then
    for k, v in pairs(args.text) do
        bAssert(type(v) == "string", "Malformed text", 1)
    end
end

self.text = args.text or {}
self.variables = args.variables or {}
self.formattedText = {}

if type(args.margin) == "number" then
    self.margin_left, self.margin_right, self.margin_top, self.margin_bottom = args.margin, args.margin, args.margin, args.margin
end

self.margin_left = type(args.margin_left) == "number" and args.margin_left or self.margin_left or 0
self.margin_right = type(args.margin_right) == "number" and args.margin_right or self.margin_right or 0
self.margin_top = type(args.margin_top) == "number" and args.margin_top or self.margin_top or 0
self.margin_bottom = type(args.margin_bottom) == "number" and args.margin_bottom or self.margin_bottom or 0
-- Variables --


-- Functions --
local function insertVariables ( text, variables )
	return text:gsub( "$$(.-);", function ( varName )
		return variables[ varName ] or "(var:" .. varName .. ")"
	end )
end

local function formatText( text, xSize )
    if xSize < 2 then
        return {""}
    end

    local formatted = {}
    local newFormatted, xPos = {}
    local formattingOptions = {} -- 1, 2, 3 (left, middle, right)
    local currentFormatting, firstMatch = 1

    for k, v in pairs(text) do
        v = insertVariables(v, self.variables)
        formatted[#formatted+1] = ""
        formattingOptions[#formattingOptions+1] = currentFormatting
        firstMatch = v:match("^%s*[&$][RrMmLl];")

        for match in v:gmatch("[&$]*[^&$]+") do
            local formattingSign = match:match("^%s*[&$]([RrMmLl]);")

            if formattingSign then
                if not firstMatch then
                    formatted[#formatted+1] = ""
                    formattingOptions[#formattingOptions+1] = 1
                end

                formatted[#formatted] = formatted[#formatted] .. match:match("^[&$][RrMmLl];(.*)")
                currentFormatting = formattingSign:lower() == "l" and 1 or formattingSign:lower() == "m" and 2 or 3
                formattingOptions[#formattingOptions] = currentFormatting
            else
                formatted[#formatted] = formatted[#formatted] .. match
            end

            firstMatch = false
        end
    end

    for i = 1, #formatted do
        newFormatted[#newFormatted+1] = ""
        xPos = 1
        currentFormatting = formattingOptions[i]

        for match in formatted[i]:gmatch("%s*%S+") do
            local withoutColor = match:gsub("[&$][%xOo];", "")

            if #withoutColor > xSize-xPos+1 then
                while #withoutColor > xSize do
                    local rest = xSize-#newFormatted[ #newFormatted ]:gsub("[$&][%xRrLlMmo];", "")
                    local currPos, actPos = 0, 0

                    while currPos < #match do
                        if not match:sub( currPos ):match( "^[$&][%xo];" ) then
                            if actPos >= rest-1 then
                                break
                            end
                            currPos = currPos + 1
                            actPos = actPos + 1
                        else
                            currPos = currPos + 3
                        end
                    end

                    newFormatted[#newFormatted] = newFormatted[#newFormatted] .. match:sub(1, currPos) .. "-"
                    match = match:sub(currPos+1)
                    withoutColor = match:gsub("[$&][%xOo];", "")

                    if #withoutColor > xSize then
                        newFormatted[#newFormatted+1] = ""
                        table.insert(formattingOptions, i, currentFormatting)
                    end
                end

                match = match:match( "%S+" )
                newFormatted[ #newFormatted+1 ] = match
                table.insert(formattingOptions, i, currentFormatting)
                xPos = #match
            else
                newFormatted[ #newFormatted ] = newFormatted[ #newFormatted ] .. match
                xPos = xPos + #match:gsub( "[$&][%xo];", "" )
            end
        end
    end

    for k, v in pairs(newFormatted) do
        if formattingOptions[k] == 2 then
            newFormatted[k] = (" "):rep(math.floor((xSize-#(v:gsub( "[&$][%xOo]", "" )))/2)) .. v
        elseif formattingOptions[k] == 3 then
            newFormatted[k] = (" "):rep(xSize-#v) .. v
        end
    end

    return newFormatted
end

local function formatColors( text, original_fg, original_bg )
    local current_fg, current_bg = original_fg, original_bg
    local match, color_match
    local formatted = {}

    for k, v in pairs(text) do
        formatted[#formatted+1] = {"", "", ""}

        while #v > 0 do
            color_match = v:match("^[$&][%xOo];")

            if not color_match then
                match = v:match("(.+)[$&][%xOo];")
            end

            if color_match then
                if color_match:sub(1, 1) == "&" then
                    current_fg = color_match:sub(2, 2)
                    current_fg = current_fg:lower() == "o" and original_fg or current_fg
                else
                    current_bg = color_match:sub(2, 2)
                    current_bg = current_bg:lower() == "o" and original_bg or current_bg
                end

                v = v:sub(4)
            else
                match = match or v

                formatted[#formatted][1] = formatted[#formatted][1] .. match
                formatted[#formatted][2] = formatted[#formatted][2] .. current_fg:rep(#match)
                formatted[#formatted][3] = formatted[#formatted][3] .. current_bg:rep(#match)

                v = v:sub(#match+1)
            end
        end
    end

    return formatted
end

local function processText()
    self.formattedText = formatColors(formatText(self.text, self.boundaries.x2-self.boundaries.x1-self.margin_left-self.margin_right+1), self.fg_color, self.bg_color)
end

local function draw( forceCalculation )
	if #self.boundaries == 0 or self.forcedCalculation then
		self.boundaries = object.getBounds()
	end

	if #self.formattedText == 0 or self.forcedCalculation then
		processText()
	end


	local lineLength = self.boundaries.x2-self.boundaries.x1+1

	term.setTextColor(reverseLookup[self.fg_color])
	term.setBackgroundColor(reverseLookup[self.bg_color])

	for y = self.boundaries.y1, self.boundaries.y2 do
		local textPos = y-self.boundaries.y1-self.margin_top+1
		term.setCursorPos(self.boundaries.x1, y)
		term.blit((" "):rep(lineLength), self.fg_color:rep(lineLength), self.bg_color:rep(lineLength))
		term.setCursorPos(self.boundaries.x1+self.margin_left, y)

		if self.formattedText[textPos] and textPos <= self.boundaries.y2-self.boundaries.y1-self.margin_bottom+1 then
			term.blit(self.formattedText[textPos][1], self.formattedText[textPos][2], self.formattedText[textPos][3])
		end
	end

	for k, v in pairs(self.children) do
		v.draw()
	end
end

local function setText( text )
    bAssert(type(text) == "table", "Text must be given in table form", 1)

    self.text = {}

    for k, v in pairs(text) do
        if type(v) == "string" then
            self.text[#self.text+1] = v
        end
    end

    if #self.boundaries == 0 or self.forcedCalculation then
        self.boundaries = object.getBounds()
    end

    processText()
end

local function setVariable( name, value )
    self.variables[name] = value
    self.forcedCalculation = true
end

local function getText()
    local text = {}

    for i = 1, #self.text do
        text[i] = self.text[i]
    end

    return text
end
-- Functions --

-- Returning of element --
object.draw = draw
object.setText = setText
object.getText = getText
object.setVariable = setVariable

return object
-- Returning of element --
