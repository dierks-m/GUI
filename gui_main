-- Variables --
local component = require("component")

local GUIElements = {
	CanvasObject	=	{".gui/CanvasObject", 0x01};
	TextArea		=	{".gui/TextArea", 0x02};
	Button			=	{".gui/Button", 0x04};
	Input			=	{".gui/Input", 0x08}
}

local dependencies = {
	CanvasObject	=	{};
	TextArea		=	{"CanvasObject"};
	Button			=	{"CanvasObject", "TextArea"};
	Input			=	{"CanvasObject"}
}

local lookup = {
	black		=	"f";
	red			=	"e";
	green		=	"d";
	brown		=	"c";
	blue		=	"b";
	purple		=	"a";
	cyan		=	"9";
	lightGrey	=	"8";
	lightGray	=	"8";
	grey		=	"7";
	gray		=	"7";
	print		=	"6";
	lime		=	"5";
	yellow		=	"4";
	lightBlue	=	"3";
	magenta		=	"2";
	orange		=	"1";
	white		=	"0";
}

local reverseLookup = {
	[ "f" ]	=	32768;
	[ "e" ]	=	16384;
	[ "d" ] =	8192;
	[ "c" ] =	4096;
	[ "b" ] =	2048;
	[ "a" ] =	1024;
	[ "9" ] =	512;
	[ "8" ] =	256;
	[ "7" ] =	128;
	[ "6" ] =	64;
	[ "5" ] =	32;
	[ "4" ] =	16;
	[ "3" ] =	8;
	[ "2" ] =	4;
	[ "1" ] =	2;
	[ "0" ] =	1;
}

local standardPalette = {
    0x000000;
    0xFF0000;
    0x008000;
    0xA52A2A;
    0x0000FF;
    0x800080;
    0x00FFFF;
    0xD3D3D3;
    0x808080;
    0xFFC0CB;
    0x00FF00;
    0xFFFF00;
    0xADD8E6;
    0xFF00FF;
    0xFFA500;
    0xFFFFFF;
}

_G.screen = {
    xPos    =   0;
    yPos    =   0;
}
local gpu = component.gpu
local term = require( "term" )
-- Variables --


-- Functions --
_G.screen.setCursorPos = function( x, y )
    assert( type(x) == "number" and type(y) == "number", "Arguments must be numbers" )
    _G.screen.xPos = x
    _G.screen.yPos = y
end

_G.screen.blit = function( text, fg, bg )
    while #text > 0 do
        local fg_match, bg_match = fg:match( fg:sub( 1, 1 ) .. "+" ), bg:match( bg:sub( 1, 1 ) .. "+" )
        local fg_color, bg_color = fg_match and fg_match:sub( 1, 1 ), bg_match and bg_match:sub( 1, 1 )
        local len = math.min( fg_match and #fg_match or #text, bg_match and #bg_match or #text )

        if fg_color then
            gpu.setForeground( tonumber( fg_color, 16 ), true )
        end

        if bg_color then
            gpu.setBackground( tonumber( bg_color, 16 ), true )
        end

        gpu.set( _G.screen.xPos, _G.screen.yPos, text:sub( 1, len ) )
        _G.screen.xPos = _G.screen.xPos + len
        text, fg, bg = text:sub( len+1 ), fg:sub( len+1 ), bg:sub( len+1 )
    end
end

_G.screen.getSize = function()
    return gpu.getResolution()
end

_G.screen.setCursorBlink = function( bool )
    term.setCursorBlink( bool )
end

local function bAssert ( state, msg, errLevel )
	--[[
		Basically a better assert in that way that it faults the caller, not the called function
	]]--
	if not state then
		error( msg, 3+( type( errLevel ) == "number" and errLevel or 0 ) )
	end
end

local function loadElement( name, env )
	return loadfile(GUIElements[name][1], "bt", env)
end

function createGUIObject( args, objectType, parent, redirect )
	local self, object = {}, parent

	local environment = {
		lookup			=	lookup;
		reverseLookup	=	reverseLookup;
		bAssert			=	bAssert;
		self			=	self;
		screen			=	redirect or screen;
	}

	setmetatable(environment, {__index=_G})

	for k, v in pairs(dependencies[objectType]) do
		object = loadElement(v, environment)(args, object)
	end

	object = loadElement(objectType, environment)(args, object)

	return object
end

function checkCanvasForClick( element, x, y )
	local matches = {}

	if element.GUIObjectType == GUIElements.Button[2] then
		if element.isClicked(x, y) then
			matches[#matches+1] = element
		end
	end

	for k, v in pairs(element.children) do
		local hits = checkCanvasForClick(v, x, y)

		for i = 1, #hits do
			matches[#matches+1] = hits[i]
		end
	end

	return matches
end

function lookupColor( color )
	return lookup[ color ]
end
-- Functions --

for i = 1, #standardPalette do
    gpu.setPaletteColor( i-1, standardPalette[i] )
end

return {
    createGUIObject = createGUIObject;
    checkCanvasForClick = checkCanvasForClick;
}
